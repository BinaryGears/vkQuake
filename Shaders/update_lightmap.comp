#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
#extension GL_EXT_samplerless_texture_functions : enable
// #extension GL_EXT_debug_printf : enable

#define MAX_LIGHTSYTLES 64
#define MAX_DLIGHTS		64
#define MAXLIGHTMAPS	4

layout (push_constant) uniform PushConsts
{
	uint num_dlights;
	uint lightmap_width;
}
push_constants;

struct surface_t
{
	uint  packed_lightstyles;
	float normal_x;
	float normal_y;
	float normal_z;
	float dist;
	uint  packed_light_st;
	uint  packed_tex_edgecount;
	uint  vbo_offset;
	vec4  vecs[2];
};

struct bounds_t
{
	float mins_x;
	float mins_y;
	float mins_z;
	float maxs_x;
	float maxs_y;
	float maxs_z;
};

struct light_t
{
	vec3  origin;
	float radius;
	vec3  color;
	float minlight;
};

struct world_vert_t
{
	float x;
	float y;
	float z;
	float u;
	float v;
	float s;
	float t;
};

const uint	LIGHT_MASK_SIZE = (MAX_DLIGHTS + 31) / 32;
shared uint light_mask[LIGHT_MASK_SIZE];

layout (set = 0, binding = 0, rgba8) uniform writeonly image2D output_image;
layout (set = 0, binding = 1) uniform utexture2D surface_indices;
layout (set = 0, binding = 2) uniform texture2D lightstyles_textures[MAXLIGHTMAPS * 3 / 4];
layout (std430, set = 0, binding = 3) restrict readonly buffer surfaces_buffer
{
	surface_t surfaces[];
};
layout (std430, set = 0, binding = 4) restrict readonly buffer workgroup_bounds_buffer
{
	bounds_t workgroup_bounds[];
};
layout (std140, set = 0, binding = 5) uniform lightstyle_scales_buffer
{
	vec4 lightstyle_scales[MAX_LIGHTSYTLES / 4];
};
layout (std140, set = 0, binding = 6) uniform lights_buffer
{
	light_t lights[MAX_DLIGHTS];
};
layout (std430, set = 0, binding = 7) readonly restrict buffer world_verts_buffer
{
	world_vert_t world_verts[];
};

layout (constant_id = 0) const bool scaled_lm = false;

bool TestSphereAABB (light_t light, vec3 mins, vec3 maxs)
{
	float sq_dist = 0.0f;
	for (int i = 0; i < 3; ++i)
	{
		// For each axis count any excess distance outside box extents
		float v = light.origin[i];
		if (v < mins[i])
			sq_dist += (mins[i] - v) * (mins[i] - v);
		if (v > maxs[i])
			sq_dist += (v - maxs[i]) * (v - maxs[i]);
	}
	return sq_dist <= light.radius * light.radius;
}

vec3 CalculateWorldPos (const surface_t surf, const float s, const float t)
{
	const vec3 normal = vec3 (surf.normal_x, surf.normal_y, surf.normal_z);
	const vec3 pos_edge1 = (abs (normal.x) > abs (normal.z)) ? vec3 (-normal.y, normal.x, 0.0f) : vec3 (0.0f, -normal.z, normal.y);
	const vec3 pos_edge2 = cross (normal, pos_edge1);

	const vec2 st_edge1 = vec2 (dot (pos_edge1, surf.vecs[0].xyz), dot (pos_edge1, surf.vecs[1].xyz));
	const vec2 st_edge2 = vec2 (dot (pos_edge2, surf.vecs[0].xyz), dot (pos_edge2, surf.vecs[1].xyz));

	const float scale = 16.0f / ((st_edge1.x * st_edge2.y) - (st_edge2.x * st_edge1.y));
	const vec3	tangent = scale * vec3 (
									  (st_edge2.y * pos_edge1.x) + (-st_edge1.y * pos_edge2.x), (st_edge2.y * pos_edge1.y) + (-st_edge1.y * pos_edge2.y),
									  (st_edge2.y * pos_edge1.z) + (-st_edge1.y * pos_edge2.z));
	const vec3 bitangent = scale * vec3 (
									   (-st_edge2.x * pos_edge1.x) + (st_edge1.x * pos_edge2.x), (-st_edge2.x * pos_edge1.y) + (st_edge1.x * pos_edge2.y),
									   (-st_edge2.x * pos_edge1.z) + (st_edge1.x * pos_edge2.z));

	const world_vert_t vert = world_verts[surf.vbo_offset];
	const vec3		   vert1_pos = vec3 (vert.x, vert.y, vert.z);
	const float		   vert1_offset_s = -(dot (vert1_pos, surf.vecs[0].xyz) + surf.vecs[0].w) / 16.0f;
	const float		   vert1_offset_t = -(dot (vert1_pos, surf.vecs[1].xyz) + surf.vecs[1].w) / 16.0f;

	return vert1_pos + ((s + vert1_offset_s) * tangent) + ((t + vert1_offset_t) * bitangent);
}

layout (local_size_x = 8, local_size_y = 8) in;
void main ()
{
	const uint workgroup_size = gl_WorkGroupSize.x * gl_WorkGroupSize.y;
	for (uint mask_index = gl_LocalInvocationIndex; mask_index < LIGHT_MASK_SIZE; mask_index += workgroup_size)
		light_mask[mask_index] = 0;

	barrier ();

	const uint workgroup_index = gl_WorkGroupID.x + ((push_constants.lightmap_width / 8) * gl_WorkGroupID.y);
	const uint num_cull_iterations = (MAX_DLIGHTS + workgroup_size - 1) / workgroup_size;
	for (uint iter = 0; iter < num_cull_iterations; ++iter)
	{
		const uint light_index = (iter * workgroup_size) + gl_LocalInvocationIndex;
		if (light_index < push_constants.num_dlights)
		{
			const light_t light = lights[light_index];
			if (light.radius == 0.0f)
				continue;
			const bounds_t bounds = workgroup_bounds[workgroup_index];
			const vec3	   mins = vec3 (bounds.mins_x, bounds.mins_y, bounds.mins_z);
			const vec3	   maxs = vec3 (bounds.maxs_x, bounds.maxs_y, bounds.maxs_z);
			const bool	   light_intersects = TestSphereAABB (light, mins, maxs);
			if (light_intersects)
				atomicOr (light_mask[light_index / 32], 1u << (light_index % 32));
		}
	}

	barrier ();

	const uint surface_index = texelFetch (surface_indices, ivec2 (gl_GlobalInvocationID.xy), 0).x;

	// Early out if no surface for lightmap texel
	if (surface_index == 0xFFFFFFFF)
		return;

	const surface_t surf = surfaces[surface_index];
	const uint		packed_lighstyles = surf.packed_lightstyles;

	const uint lightstyles[4] = {
		(packed_lighstyles >> 0) & 0xFF, (packed_lighstyles >> 8) & 0xFF, (packed_lighstyles >> 16) & 0xFF, (packed_lighstyles >> 24) & 0xFF};

	vec3 light_accumulated = vec3 (0.0f, 0.0f, 0.0f);
	vec3 fourth_lightmap;
	for (int i = 0; i < MAXLIGHTMAPS; ++i)
	{
		const uint style = lightstyles[i];
		if (style == 255)
			break;
		const float scale = lightstyle_scales[style / 4][style % 4];
		if (i < 3)
		{
			const vec4 sample_tex = texelFetch (lightstyles_textures[i], ivec2 (gl_GlobalInvocationID.xy), 0);
			light_accumulated += scale * sample_tex.xyz;
			fourth_lightmap[i] = sample_tex.w;
		}
		else
			light_accumulated += scale * fourth_lightmap;
	}

	for (uint light_mask_index = 0; light_mask_index < LIGHT_MASK_SIZE; ++light_mask_index)
	{
		uint mask = light_mask[light_mask_index];
		while (mask != 0)
		{
			const uint light_offset = findLSB (mask);
			mask &= ~(1u << light_offset);
			const uint light_index = (light_mask_index * 32) + light_offset;

			const light_t light = lights[light_index];
			const float	  s = float (gl_GlobalInvocationID.x - (surf.packed_light_st & 0xFFFF));
			const float	  t = float (gl_GlobalInvocationID.y - (surf.packed_light_st >> 16));
			const vec3	  world_pos = CalculateWorldPos (surf, s, t);
			const float	  dist = length (world_pos - light.origin);

			float rad = light.radius;
			float minlight = light.minlight;

			if (dist < (rad - minlight))
			{
				float brightness = (rad - dist) / 256.0f;
				light_accumulated.xyz += brightness * light.color;
			}
		}
	}

	if (scaled_lm)
		light_accumulated *= 0.25f;
	imageStore (output_image, ivec2 (gl_GlobalInvocationID.xy), vec4 (light_accumulated, 0.0f));
}
